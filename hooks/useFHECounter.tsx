"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve 
  deployment information for FHEMessageBoard.sol:
  
  - <root>/packages/site/abi/abi/FHECounterABI.ts
  - <root>/packages/site/abi/abi/FHECounterAddresses.ts
*/
import { FHECounterAddresses } from "@/abi/FHECounterAddresses";
import { FHECounterABI } from "@/abi/FHECounterABI";

export type ClearMessageType = {
  handle: string;
  clear: string;
};

export type MessageInfo = {
  sender: string;
  recipient: string;
  timestamp: number;
  canDecrypt: boolean;
};
type FHECounterInfoType = {
  abi: typeof FHECounterABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves FHEMessageBoard contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getFHECounterByChainId(chainId);
 */
function getFHECounterByChainId(
  chainId: number | undefined
): FHECounterInfoType {
  if (!chainId) {
    return { abi: FHECounterABI.abi };
  }

  const entry =
    FHECounterAddresses[chainId.toString() as keyof typeof FHECounterAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: FHECounterABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: FHECounterABI.abi,
  };
}

/*
 * Main FHECounter React component with 3 buttons
 *  - "Decrypt" button: allows you to decrypt the current FHECounter count handle.
 *  - "Increment" button: allows you to increment the FHECounter count handle using FHE operations.
 *  - "Decrement" button: allows you to decrement the FHECounter count handle using FHE operations.
 */
export const useFHECounter = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs (refs are mostly used to access latest React values and avoid
  // state dependencies). Consider @tanstack/react-query as an alternative to
  // handle async operations like FHEVM encryption/decryption
  //////////////////////////////////////////////////////////////////////////////

  const [sentMessages, setSentMessages] = useState<number[]>([]);
  const [receivedMessages, setReceivedMessages] = useState<number[]>([]);
  const [messageContents, setMessageContents] = useState<{[key: number]: ClearMessageType}>({});
  const [messageInfos, setMessageInfos] = useState<{[key: number]: MessageInfo}>({});
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSending, setIsSending] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const fheCounterRef = useRef<FHECounterInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSendingRef = useRef<boolean>(isSending);

  const totalMessages = sentMessages.length + receivedMessages.length;

  //////////////////////////////////////////////////////////////////////////////
  // FHEMessageBoard
  //////////////////////////////////////////////////////////////////////////////

  const fheCounter = useMemo(() => {
    const c = getFHECounterByChainId(chainId);

    fheCounterRef.current = c;

    if (!c.address) {
      setMessage(`FHEMessageBoard deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Message Lists
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!fheCounter) {
      return undefined;
    }
    return (Boolean(fheCounter.address) && fheCounter.address !== ethers.ZeroAddress);
  }, [fheCounter]);

  const canGetMessages = useMemo(() => {
    return fheCounter.address && ethersReadonlyProvider && ethersSigner && !isRefreshing;
  }, [fheCounter.address, ethersReadonlyProvider, ethersSigner, isRefreshing]);

  const refreshMessages = useCallback(() => {
    console.log("[useFHECounter] call refreshMessages()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !fheCounterRef.current ||
      !fheCounterRef.current?.chainId ||
      !fheCounterRef.current?.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      setSentMessages([]);
      setReceivedMessages([]);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = fheCounterRef.current.chainId;
    const thisFheCounterAddress = fheCounterRef.current.address;

    const thisFheCounterContract = new ethers.Contract(
      thisFheCounterAddress,
      fheCounterRef.current.abi,
      ethersSigner  // Use ethersSigner instead of ethersReadonlyProvider to get msg.sender
    );
    Promise.all([
      //thisFheCounterContract.getAddress(),
      thisFheCounterContract.getSentMessages(),
      thisFheCounterContract.getReceivedMessages()
    ])
      .then(([sent, received]) => {
        //console.log("Contract Addressï¼š" + addr)
        console.log("[useFHECounter] getSentMessages()=" + sent);
        console.log("[useFHECounter] getReceivedMessages()=" + received);
        if (
          sameChain.current(thisChainId) &&
          thisFheCounterAddress === fheCounterRef.current?.address
        ) {
          setSentMessages(sent.map((id: any) => Number(id)));
          setReceivedMessages(received.map((id: any) => Number(id)));
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("FHEMessageBoard.getMessages() call failed! error=" + e);

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  // Auto refresh the messages
  useEffect(() => {
    refreshMessages();
  }, [refreshMessages]);

  //////////////////////////////////////////////////////////////////////////////
  // Message Decryption
  //////////////////////////////////////////////////////////////////////////////

  const canDecrypt = useMemo(() => {
    return (
      fheCounter.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      receivedMessages.length > 0
    );
  }, [
    fheCounter.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    receivedMessages,
  ]);

  /**
   * Asynchronous FHEVM message decryption process.
   *
   * - Prevents double execution by using `isDecryptingRef` as a guard.
   * - Decrypts messages that the current user is the recipient of.
   * - Verifies if the decryption result is stale by comparing the current `chainId`, `contract address`, and `signer`.
   */
  const decryptMessage = useCallback((messageId: number) => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!fheCounter.address || !instance || !ethersSigner) {
      return;
    }

    // Already decrypted
    if (messageContents[messageId]) {
      return;
    }

    const thisChainId = chainId;
    const thisFheCounterAddress = fheCounter.address;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage(`Start decrypt message ${messageId}`);

    const run = async () => {
      const isStale = () =>
        thisFheCounterAddress !== fheCounterRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const thisFheCounterContract = new ethers.Contract(
          thisFheCounterAddress,
          fheCounter.abi,
          thisEthersSigner
        );

        // Get message handle
        const messageHandle = await thisFheCounterContract.getMessage(messageId);

        if (isStale()) {
          setMessage("Ignore message decryption");
          return;
        }

        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [fheCounter.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        // should be ok even if instance changed
        const res = await instance.userDecrypt(
          [{ handle: messageHandle, contractAddress: thisFheCounterAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        const decryptedContent = res[messageHandle];
        
        // Convert the decrypted number back to string
        let decodedMessage = "";
        try {
          // Convert the number back to bytes and then to string
          const numberValue = BigInt(decryptedContent);
          const buffer = new ArrayBuffer(8);
          const dataView = new DataView(buffer);
          dataView.setBigUint64(0, numberValue, false); // big-endian
          const uint8Array = new Uint8Array(buffer);
          // Remove null bytes and decode
          const trimmedArray = uint8Array.filter(byte => byte !== 0);
          decodedMessage = new TextDecoder().decode(trimmedArray);
        } catch (error) {
          console.error("Failed to decode message:", error);
          decodedMessage = String(decryptedContent); // Fallback to raw number
        }
        
        setMessageContents(prev => ({
          ...prev,
          [messageId]: { handle: messageHandle, clear: decodedMessage }
        }));

        setMessage(`Message ${messageId} decrypted: ${decodedMessage}`);
      } catch (error) {
        setMessage(`Failed to decrypt message ${messageId}: ${error}`);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    fheCounter.address,
    fheCounter.abi,
    instance,
    messageContents,
    chainId,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Send Message
  //////////////////////////////////////////////////////////////////////////////

  const canSendMessage = useMemo(() => {
    return (
      fheCounter.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSending
    );
  }, [fheCounter.address, instance, ethersSigner, isRefreshing, isSending]);

  /**
   * Asynchronous FHEVM message sending process.
   *
   * - Prevents double execution by using `isSendingRef` as a guard.
   * - Encrypts and sends a message to the specified recipient.
   * - Verifies if the operation result is stale by comparing the current `chainId`, `contract address`, and `signer`.
   */
  const sendMessage = useCallback(
    (recipient: string, messageText: string) => {
      if (isRefreshingRef.current || isSendingRef.current) {
        return;
      }

      if (!fheCounter.address || !instance || !ethersSigner || !recipient || !messageText) {
        return;
      }

      const thisChainId = chainId;
      const thisFheCounterAddress = fheCounter.address;
      const thisEthersSigner = ethersSigner;
      const thisFheCounterContract = new ethers.Contract(
        thisFheCounterAddress,
        fheCounter.abi,
        thisEthersSigner
      );

      isSendingRef.current = true;
      setIsSending(true);
      setMessage(`Sending message to ${recipient}...`);

      const run = async () => {
        // let the browser repaint before running 'input.encrypt()' (CPU-costly)
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisFheCounterAddress !== fheCounterRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisFheCounterAddress,
            thisEthersSigner.address
          );

          // Convert string message to number for encryption (simple encoding)
          // For better encoding, you might want to use proper string-to-number conversion
          const messageBytes = new TextEncoder().encode(messageText);
          const paddedBytes = new Uint8Array(8);
          paddedBytes.set(messageBytes.slice(0, 8)); // Take first 8 bytes
          const dataView = new DataView(paddedBytes.buffer);
          const messageNumber = dataView.getBigUint64(0, false); // big-endian
          input.add64(Number(messageNumber));

          // is CPU-intensive (browser may freeze a little when FHE-WASM modules are loading)
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore send message");
            return;
          }

          setMessage("Calling sendMessage...");

          // Call contract
          const tx: ethers.TransactionResponse = await thisFheCounterContract.sendMessage(
            recipient,
            enc.handles[0],
            enc.inputProof
          );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Send message completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore send message");
            return;
          }

          refreshMessages();
        } catch (error) {
          setMessage(`Send message failed! ${error}`);
        } finally {
          isSendingRef.current = false;
          setIsSending(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      fheCounter.address,
      fheCounter.abi,
      instance,
      chainId,
      refreshMessages,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: fheCounter.address,
    canDecrypt,
    canGetMessages,
    canSendMessage,
    sendMessage,
    decryptMessage,
    refreshMessages,
    sentMessages,
    receivedMessages,
    messageContents,
    messageInfos,
    message,
    isDecrypting,
    isRefreshing,
    isSending,
    isDeployed
  };
};
